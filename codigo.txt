import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LogIPPorPuerto {

    // Regex para IP:PUERTO
    private static final Pattern IP_PUERTO_PATTERN =
            Pattern.compile("\\b(\\d{1,3}(?:\\.\\d{1,3}){3}):(\\d{1,5})\\b");

    public static void main(String[] args) {

        // ðŸ”§ CAMBIA ESTA RUTA
        Path logFile = Paths.get("C:\\ruta\\a\\tu\\archivo.log");

        try {
            Map<Integer, Set<String>> resultado = obtenerIPsPorPuerto(logFile);

            imprimirResultado(resultado);

        } catch (IOException e) {
            System.err.println("Error leyendo el archivo: " + e.getMessage());
        }
    }

    public static Map<Integer, Set<String>> obtenerIPsPorPuerto(Path archivo) throws IOException {

        Map<Integer, Set<String>> puertoIpsMap = new HashMap<>();

        try (BufferedReader reader = Files.newBufferedReader(archivo, StandardCharsets.UTF_8)) {
            String linea;

            while ((linea = reader.readLine()) != null) {

                Matcher matcher = IP_PUERTO_PATTERN.matcher(linea);

                while (matcher.find()) {
                    String ip = matcher.group(1);
                    int puerto = Integer.parseInt(matcher.group(2));

                    puertoIpsMap
                            .computeIfAbsent(puerto, p -> new HashSet<>())
                            .add(ip);
                }
            }
        }

        return puertoIpsMap;
    }

    private static void imprimirResultado(Map<Integer, Set<String>> data) {

        if (data.isEmpty()) {
            System.out.println("No se encontraron IPs con puerto.");
            return;
        }

        System.out.println("IPs agrupadas por puerto:");
        System.out.println("================================");

        data.entrySet().stream()
                .sorted(Map.Entry.comparingByKey())
                .forEach(entry -> {
                    System.out.println("Puerto " + entry.getKey() + ":");
                    for (String ip : entry.getValue()) {
                        System.out.println("  - " + ip);
                    }
                });
    }
}


-------------------------------------------------------------------

import org.knowm.xchart.BitmapEncoder;
import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GraficaIPsPorPuerto {

    private static final Pattern IP_PUERTO_PATTERN =
            Pattern.compile("\\b(\\d{1,3}(?:\\.\\d{1,3}){3}):(\\d{1,5})\\b");

    public static void main(String[] args) throws Exception {

        Path logFile = Paths.get("C:\\ruta\\a\\tu\\archivo.log"); // <-- cambia esto

        Map<Integer, Set<String>> ipsPorPuerto = obtenerIPsPorPuerto(logFile);

        // Ejemplo: graficar "puerto vs #IPs Ãºnicas"
        Path salidaPng = Paths.get("C:\\ruta\\a\\tu\\salida\\ips_por_puerto.png");
        graficarBarrasPuertos(ipsPorPuerto, salidaPng);

        System.out.println("GrÃ¡fica generada en: " + salidaPng.toAbsolutePath());
    }

    public static Map<Integer, Set<String>> obtenerIPsPorPuerto(Path archivo) throws IOException {
        Map<Integer, Set<String>> puertoIpsMap = new HashMap<>();

        try (BufferedReader reader = Files.newBufferedReader(archivo, StandardCharsets.UTF_8)) {
            String linea;
            while ((linea = reader.readLine()) != null) {
                Matcher matcher = IP_PUERTO_PATTERN.matcher(linea);
                while (matcher.find()) {
                    String ip = matcher.group(1);
                    int puerto = Integer.parseInt(matcher.group(2));

                    puertoIpsMap
                            .computeIfAbsent(puerto, p -> new HashSet<>())
                            .add(ip);
                }
            }
        }
        return puertoIpsMap;
    }

    public static void graficarBarrasPuertos(Map<Integer, Set<String>> ipsPorPuerto, Path salidaPng)
            throws IOException {

        if (ipsPorPuerto.isEmpty()) {
            System.out.println("No hay datos para graficar.");
            return;
        }

        // Ordenar por puerto
        List<Integer> puertos = new ArrayList<>(ipsPorPuerto.keySet());
        Collections.sort(puertos);

        List<String> xLabels = new ArrayList<>();
        List<Integer> yValores = new ArrayList<>();

        for (Integer p : puertos) {
            xLabels.add(String.valueOf(p));
            yValores.add(ipsPorPuerto.get(p).size()); // # de IPs Ãºnicas por puerto
        }

        CategoryChart chart = new CategoryChartBuilder()
                .title("IPs Ãºnicas por puerto")
                .xAxisTitle("Puerto")
                .yAxisTitle("Cantidad de IPs Ãºnicas")
                .width(1200)
                .height(700)
                .build();

        chart.addSeries("IPs Ãºnicas", xLabels, yValores);

        Files.createDirectories(salidaPng.getParent());
        BitmapEncoder.saveBitmap(chart, salidaPng.toString(), BitmapEncoder.BitmapFormat.PNG);
    }
}